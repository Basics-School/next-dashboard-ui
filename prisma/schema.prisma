generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    url      = env("DATABASE_URL")
}

model Academy {
    id           String        @id @default(cuid())
    name         String        @unique
    slug         String        @unique
    createdAt    DateTime      @default(now())
    updatedAt    DateTime      @updatedAt
    users        User[]
    courses      Course[]
    students     Student[]
    teachers     Teacher[]
    staff        Staff[]
    invoices     Invoice[]
    payments     Payment[]
    installments Installment[]

    @@map("academies")
}

model User {
    id            String          @id @default(cuid())
    name          String?
    email         String          @unique
    emailVerified DateTime?
    image         String?
    phoneNumber   String?
    accounts      Account[]
    sessions      Session[]
    Authenticator Authenticator[]
    roles         UserRole[]
    academyId     String?
    academy       Academy?        @relation(fields: [academyId], references: [id], onDelete: SetNull)
    createdAt     DateTime        @default(now())
    updatedAt     DateTime        @updatedAt
    teacher       Teacher?
    student       Student?
    parent        Parent?
    staff         Staff?

    @@map("users")
}

model Role {
    id          String       @id @default(cuid())
    name        String       @unique
    description String?
    permissions Permission[] @relation("RolePermissions")
    users       UserRole[]

    @@map("roles")
}

model Permission {
    id          String  @id @default(cuid())
    name        String  @unique
    description String?
    roles       Role[]  @relation("RolePermissions")

    @@map("permissions")
}

model UserRole {
    id     String @id @default(cuid())
    userId String
    roleId String
    user   User   @relation(fields: [userId], references: [id], onDelete: Cascade)
    role   Role   @relation(fields: [roleId], references: [id], onDelete: Cascade)

    @@unique([userId, roleId])
    @@map("user_roles")
}

model Teacher {
    id        String   @id @default(cuid())
    userId    String   @unique
    academyId String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    academy   Academy  @relation(fields: [academyId], references: [id], onDelete: Cascade)
    courses   Course[]
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("teachers")
}

model Student {
    id        String    @id @default(cuid())
    userId    String    @unique
    academyId String
    user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    academy   Academy   @relation(fields: [academyId], references: [id], onDelete: Cascade)
    parent    Parent?   @relation(fields: [parentid], references: [id])
    parentid  String?
    courses   Course[]
    invoices  Invoice[]
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt

    @@map("students")
}

model Parent {
    id        String    @id @default(cuid())
    userId    String    @unique
    user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
    children  Student[]
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt

    @@map("parents")
}

model Staff {
    id        String   @id @default(cuid())
    userId    String   @unique
    academyId String
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
    academy   Academy  @relation(fields: [academyId], references: [id], onDelete: Cascade)
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("staff")
}

model Course {
    id        String    @id @default(cuid())
    name      String
    academyId String
    teacherId String?
    students  Student[]
    teacher   Teacher?  @relation(fields: [teacherId], references: [id], onDelete: SetNull)
    academy   Academy   @relation(fields: [academyId], references: [id], onDelete: Cascade)
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt

    @@map("courses")
}

model Invoice {
    id           String        @id @default(cuid())
    academyId    String
    studentId    String
    amount       Float
    status       String        @default("unpaid") // Can be 'unpaid', 'paid', 'partially_paid'
    issuedAt     DateTime      @default(now())
    dueDate      DateTime
    installments Installment[]
    payments     Payment[]
    academy      Academy       @relation(fields: [academyId], references: [id], onDelete: Cascade)
    student      Student       @relation(fields: [studentId], references: [id], onDelete: Cascade)

    @@map("invoices")
}

model Installment {
    id        String   @id @default(cuid())
    invoiceId String
    amount    Float
    dueDate   DateTime
    status    String   @default("pending") // Can be 'pending', 'paid', 'overdue'
    invoice   Invoice  @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
    academyId String
    academy   Academy  @relation(fields: [academyId], references: [id], onDelete: Cascade)

    @@map("installments")
}

model Payment {
    id          String    @id @default(cuid())
    invoiceId   String
    amount      Float
    paymentDate DateTime  @default(now())
    invoice     Invoice   @relation(fields: [invoiceId], references: [id], onDelete: Cascade)
    createdAt   DateTime  @default(now())
    updatedAt   DateTime  @updatedAt
    Academy     Academy[]

    @@map("payments")
}

model Account {
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String?
    access_token      String?
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String?
    session_state     String?

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@id([provider, providerAccountId])
    @@map("accounts")
}

model Session {
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    @@map("sessions")
}

model VerificationToken {
    identifier String
    token      String
    expires    DateTime

    @@id([identifier, token])
    @@map("verification_tokens")
}

model Authenticator {
    credentialID         String  @unique
    userId               String
    providerAccountId    String
    credentialPublicKey  String
    counter              Int
    credentialDeviceType String
    credentialBackedUp   Boolean
    transports           String?

    user User @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@id([userId, credentialID])
    @@map("authenticators")
}
